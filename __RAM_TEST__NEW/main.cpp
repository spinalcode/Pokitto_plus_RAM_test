#define screenWidth 400

int sx=0;
int sy=0;

#include <Pokitto.h>

#include "globals.h"
#include "buttonhandling.h"
#include "ram.i"

#define MISO_pin P1_21
#define MOSI_pin P1_22
#define SCLK_pin P1_20
#define CS_pin P1_5


SPI spi(MOSI_pin, MISO_pin, SCLK_pin); // mosi, miso, sclk
DigitalInOut cs(CS_pin);

char tempText[64];

unsigned char rawData[871] = {
	0x50, 0x52, 0x4F, 0x43, 0x45, 0x53, 0x53, 0x4F, 0x52, 0x0D, 0x0A, 0x4E,
	0x58, 0x50, 0x20, 0x41, 0x52, 0x4D, 0x20, 0x43, 0x6F, 0x72, 0x74, 0x65,
	0x78, 0x2D, 0x4D, 0x30, 0x2B, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73,
	0x73, 0x6F, 0x72, 0x2C, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67,
	0x20, 0x61, 0x74, 0x20, 0x34, 0x38, 0x20, 0x4D, 0x48, 0x7A, 0x20, 0x28,
	0x75, 0x73, 0x65, 0x73, 0x20, 0x31, 0x36, 0x2D, 0x62, 0x69, 0x74, 0x20,
	0x54, 0x68, 0x75, 0x6D, 0x62, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x72, 0x75,
	0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x73, 0x65, 0x74, 0x20, 0x38, 0x37,
	0x29, 0x0D, 0x0A, 0x0D, 0x0A, 0x32, 0x35, 0x36, 0x6B, 0x42, 0x20, 0x70,
	0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72,
	0x79, 0x20, 0xE2, 0x80, 0x93, 0x20, 0x33, 0x36, 0x6B, 0x42, 0x20, 0x52,
	0x41, 0x4D, 0x20, 0xE2, 0x80, 0x93, 0x20, 0x34, 0x6B, 0x42, 0x20, 0x45,
	0x45, 0x50, 0x52, 0x4F, 0x4D, 0x0D, 0x0A, 0x0D, 0x0A, 0x47, 0x52, 0x41,
	0x50, 0x48, 0x49, 0x43, 0x53, 0x0D, 0x0A, 0x32, 0x2E, 0x30, 0xE2, 0x80,
	0xB3, 0x20, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x20, 0x54, 0x46, 0x54, 0x20,
	0x77, 0x69, 0x74, 0x68, 0x20, 0x66, 0x61, 0x73, 0x74, 0x20, 0x62, 0x75,
	0x73, 0x20, 0x28, 0x38, 0x20, 0x6D, 0x69, 0x6C, 0x6C, 0x69, 0x6F, 0x6E,
	0x20, 0x70, 0x69, 0x78, 0x65, 0x6C, 0x73, 0x2F, 0x73, 0x65, 0x63, 0x6F,
	0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x65, 0x74, 0x69, 0x63,
	0x61, 0x6C, 0x20, 0x6D, 0x61, 0x78, 0x29, 0x0D, 0x0A, 0x0D, 0x0A, 0x32,
	0x32, 0x30, 0xC3, 0x97, 0x31, 0x37, 0x36, 0x20, 0x28, 0x68, 0x69, 0x67,
	0x68, 0x20, 0x72, 0x65, 0x73, 0x6F, 0x6C, 0x75, 0x74, 0x69, 0x6F, 0x6E,
	0x29, 0x20, 0x31, 0x31, 0x30, 0xC3, 0x97, 0x38, 0x38, 0x20, 0x28, 0x66,
	0x61, 0x73, 0x74, 0x65, 0x73, 0x74, 0x20, 0x72, 0x65, 0x73, 0x6F, 0x6C,
	0x75, 0x74, 0x69, 0x6F, 0x6E, 0x29, 0x20, 0x31, 0x32, 0x38, 0xC3, 0x97,
	0x36, 0x34, 0x20, 0x28, 0x41, 0x72, 0x64, 0x75, 0x62, 0x6F, 0x79, 0x20,
	0x65, 0x6D, 0x75, 0x6C, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x29, 0x20, 0x38,
	0x34, 0xC3, 0x97, 0x34, 0x38, 0x20, 0x28, 0x47, 0x61, 0x6D, 0x65, 0x62,
	0x75, 0x69, 0x6E, 0x6F, 0x20, 0x65, 0x6D, 0x75, 0x6C, 0x61, 0x74, 0x69,
	0x6F, 0x6E, 0x29, 0x0D, 0x0A, 0x0D, 0x0A, 0x53, 0x4F, 0x55, 0x4E, 0x44,
	0x0D, 0x0A, 0x32, 0x20, 0x73, 0x69, 0x6D, 0x75, 0x6C, 0x74, 0x61, 0x6E,
	0x65, 0x6F, 0x75, 0x73, 0x20, 0x73, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x6F,
	0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61,
	0x74, 0x6F, 0x72, 0x73, 0x3A, 0x20, 0x38, 0x2D, 0x62, 0x69, 0x74, 0x20,
	0x44, 0x41, 0x43, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x38, 0x2D, 0x42, 0x69,
	0x74, 0x20, 0x50, 0x57, 0x4D, 0x0D, 0x0A, 0x0D, 0x0A, 0x42, 0x75, 0x69,
	0x6C, 0x74, 0x2D, 0x69, 0x6E, 0x20, 0x41, 0x6D, 0x70, 0x6C, 0x69, 0x66,
	0x69, 0x65, 0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x42, 0x61, 0x73,
	0x73, 0x20, 0x42, 0x6F, 0x6F, 0x73, 0x74, 0x0D, 0x0A, 0x0D, 0x0A, 0x42,
	0x75, 0x69, 0x6C, 0x74, 0x2D, 0x69, 0x6E, 0x20, 0x53, 0x70, 0x65, 0x61,
	0x6B, 0x65, 0x72, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x53, 0x74, 0x65, 0x72,
	0x65, 0x6F, 0x20, 0x48, 0x65, 0x61, 0x64, 0x70, 0x68, 0x6F, 0x6E, 0x65,
	0x20, 0x4A, 0x61, 0x63, 0x6B, 0x0D, 0x0A, 0x0D, 0x0A, 0x44, 0x69, 0x67,
	0x69, 0x74, 0x61, 0x6C, 0x20, 0x56, 0x6F, 0x6C, 0x75, 0x6D, 0x65, 0x20,
	0x43, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C, 0x20, 0x77, 0x69, 0x74, 0x68,
	0x20, 0x49, 0x32, 0x43, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C,
	0x0D, 0x0A, 0x0D, 0x0A, 0x50, 0x4F, 0x57, 0x45, 0x52, 0x0D, 0x0A, 0x36,
	0x30, 0x30, 0x20, 0x6D, 0x41, 0x68, 0x20, 0x68, 0x69, 0x67, 0x68, 0x2D,
	0x71, 0x75, 0x61, 0x6C, 0x69, 0x74, 0x79, 0x20, 0x73, 0x75, 0x70, 0x65,
	0x72, 0x66, 0x6C, 0x61, 0x74, 0x20, 0x4C, 0x69, 0x74, 0x68, 0x69, 0x75,
	0x6D, 0x2D, 0x50, 0x6F, 0x6C, 0x79, 0x6D, 0x65, 0x72, 0x20, 0x77, 0x69,
	0x74, 0x68, 0x20, 0x62, 0x75, 0x69, 0x6C, 0x74, 0x2D, 0x69, 0x6E, 0x20,
	0x63, 0x68, 0x61, 0x72, 0x67, 0x65, 0x72, 0x0D, 0x0A, 0x0D, 0x0A, 0x44,
	0x41, 0x54, 0x41, 0x53, 0x48, 0x45, 0x45, 0x54, 0x53, 0x0D, 0x0A, 0x43,
	0x50, 0x55, 0x2F, 0x4D, 0x43, 0x55, 0x3A, 0x20, 0x4C, 0x50, 0x43, 0x31,
	0x31, 0x55, 0x36, 0x78, 0x20, 0x55, 0x73, 0x65, 0x72, 0x20, 0x4D, 0x61,
	0x6E, 0x75, 0x61, 0x6C, 0x20, 0x32, 0x30, 0x0D, 0x0A, 0x43, 0x50, 0x55,
	0x2F, 0x4D, 0x43, 0x55, 0x3A, 0x20, 0x4C, 0x50, 0x43, 0x31, 0x31, 0x55,
	0x36, 0x78, 0x20, 0x44, 0x61, 0x74, 0x61, 0x73, 0x68, 0x65, 0x65, 0x74,
	0x20, 0x31, 0x30, 0x30, 0x0D, 0x0A, 0x43, 0x50, 0x55, 0x2F, 0x4D, 0x43,
	0x55, 0x3A, 0x20, 0x41, 0x52, 0x4D, 0x20, 0x43, 0x6F, 0x72, 0x74, 0x65,
	0x78, 0x2D, 0x4D, 0x30, 0x2B, 0x20, 0x54, 0x65, 0x63, 0x68, 0x6E, 0x69,
	0x63, 0x61, 0x6C, 0x20, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63,
	0x65, 0x20, 0x4D, 0x61, 0x6E, 0x75, 0x61, 0x6C, 0x20, 0x31, 0x30, 0x0D,
	0x0A, 0x54, 0x46, 0x54, 0x20, 0x53, 0x63, 0x72, 0x65, 0x65, 0x6E, 0x3A,
	0x20, 0x53, 0x54, 0x37, 0x37, 0x37, 0x35, 0x52, 0x20, 0x44, 0x61, 0x74,
	0x61, 0x73, 0x68, 0x65, 0x65, 0x74, 0x20, 0x31, 0x35, 0x35, 0x0D, 0x0A,
	0x0D, 0x0A, 0x53, 0x43, 0x52, 0x45, 0x57, 0x53, 0x0D, 0x0A, 0x43, 0x61,
	0x73, 0x65, 0x20, 0x73, 0x63, 0x72, 0x65, 0x77, 0x73, 0x3A, 0x20, 0x6D,
	0x31, 0x2E, 0x37, 0x20, 0x78, 0x20, 0x35, 0x20, 0x6D, 0x6D, 0x0D, 0x0A,
	0x4C, 0x43, 0x44, 0x20, 0x68, 0x6F, 0x6C, 0x64, 0x65, 0x72, 0x20, 0x73,
	0x63, 0x72, 0x65, 0x77, 0x3A, 0x20, 0x6D, 0x31, 0x2E, 0x37, 0x20, 0x78,
	0x20, 0x34, 0x20, 0x6D, 0x6D, 0x0D, 0x0A
};







void sendToRAM(int address, uint8_t* data, int howLong) {
    
    while (cs == 0) {
        wait_us(1);
    }

    SPI spi(MOSI_pin, MISO_pin, SCLK_pin); // mosi, miso, sclk
    cs.output();
    cs=0;

    spi.write(0x02); // Write command

    // assume SIZEOFRAM == 1024
    uint8_t temp = address >> 16;
    spi.write(temp);
    temp = address >> 8;
    spi.write(temp);
    temp = address & 255;
    spi.write(temp);

    for(int t=0; t<howLong; t++){
        spi.write(data[t]);
    }
    cs.input();

}

void getFromRAM(int address, uint8_t* data, int howLong) {

    while (cs == 0) {
        wait_us(1);
    }

    SPI spi(MOSI_pin, MISO_pin, SCLK_pin); // mosi, miso, sclk
    cs.output();
    cs=0;

    spi.write(0x03); // Read command

    // assume SIZEOFRAM == 1024
    uint8_t temp = address >> 16;
    spi.write(temp);
    temp = address >> 8;
    spi.write(temp);
    temp = address & 255;
    spi.write(temp);

    for(int t=0; t<howLong; t++){
        data[t] = spi.write(0x00); // sending dummy bytes will also read the MISO
    }
    cs.input();
}


int main(){
    using PC=Pokitto::Core;
    using PD=Pokitto::Display;
    using PB=Pokitto::Buttons;
    using PS=Pokitto::Sound;

    PC::begin();
    PD::invisiblecolor = 0;
    PD::adjustCharStep = 1;
    PD::adjustLineStep = 0;
    PD::setFont(font3x5);
    
    Pokitto::Display::load565Palette(background1_pal); // load a palette the same way as any other palette in any other screen mode

    // Setup the spi for 8 bit data, high steady state clock,
    // second edge capture, with a 1MHz clock rate
    spi.format(8, 3);
    spi.frequency(20000000);

    while( PC::isRunning() ){

        if(!PC::update()) continue;
        updateButtons();
        PD::clear();
        cs.input();
        PD::print(0,16,cs);


        if(_A[NEW]){
            if(cs==1){
                int number = 1536;
                uint8_t dataBuffer[1536];
                getFromRAM(0x00, dataBuffer, number);
        
                int x=0;
                int y=0;
                for(int t=0; t<number; t++){
                    x++;
                    if(dataBuffer[t]==13){
                        x=0;
                        y++;
                    }else{
                        if(x<55 && y<30) PD::print(x*4,y*7,dataBuffer[t]);
                    }
                }
            }
        }

        if(_B[NEW])        {
            if(cs==1){
                int number = sizeof(rawData);
                sendToRAM(0x00, rawData, number);
            }
        }
        
        sprintf(tempText,"FPS:%d",fpsCount);
        PD::print(0,0,tempText);

        fpsCounter++;

        if(PC::getTime() >= lastMillis+1000){
            PD::clear();
            lastMillis = PC::getTime();
            fpsCount = fpsCounter;
            fpsCounter = 0;
        }

    }
    
    return 0;
}
